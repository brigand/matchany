{"version":3,"sources":["webpack:///../src/IntoCondition.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"qfAMO,IAAMA,EAAe,Q,uMAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,iBADR,iBAGA,4GACA,yGACF,0BAAYC,WAAW,KAAvB,iBADE,KAEA,qEAAoD,0BAAYA,WAAW,KAAvB,yBAApD,KACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,iGAML,yHAEA,iBAAQ,CACN,GAAM,kBADR,mBAGA,0CAAyB,0BAAYA,WAAW,KAAvB,aAAzB,6DACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,oIAQL,iBAAQ,CACN,GAAM,iBADR,kBAGA,wDAAuC,0BAAYA,WAAW,KAAvB,QAAvC,KACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,6JAQL,iBAAQ,CACN,GAAM,eADR,gBAGA,qDAAoC,0BAAYA,WAAW,KAAvB,aAApC,KACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,kNASL,iBAAQ,CACN,GAAM,qBADR,sBAGA,qDAAoC,0BAAYA,WAAW,KAAvB,eAApC,2BAAuH,0BAAYA,WAAW,KAAvB,eAAvH,UACF,0BAAYA,WAAW,KAAvB,iBADE,uBAEA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,qUAsBL,iBAAQ,CACN,GAAM,kBADR,mBAGA,2FAA0E,0BAAYA,WAAW,KAAvB,MAA1E,KACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,yK,8LAWTJ,EAAWK,gBAAiB","file":"component---src-into-condition-mdx-10c7423e50cbdc99f9f4.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/fb/github/brigand/pattahn/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"intocondition\"\n    }}>{`IntoCondition`}</h1>\n    <p>{`Some APIs will convert non-Condition values to a Condition using some simple logic.`}</p>\n    <p>{`Functions that perform this conversion are documented as taking a value of type\n`}<inlineCode parentName=\"p\">{`IntoCondition`}</inlineCode>{`.`}</p>\n    <p>{`You can explicitly invoke this behavior with `}<inlineCode parentName=\"p\">{`Condition.from(value)`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import { Condition } from 'pattahn/core';\n\nexpect(Condition.from(7).test(7)).toBe(true);\n`}</code></pre>\n    <p>{`The \"Case\" sections are in order of preference (if one doesn't match, then the next is\ntried).`}</p>\n    <h2 {...{\n      \"id\": \"case-condition\"\n    }}>{`Case: Condition`}</h2>\n    <p>{`If the value is a `}<inlineCode parentName=\"p\">{`Condition`}</inlineCode>{` instance, then it's returned immediately and unmodified.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import Eq from 'pattahn/cond/Eq';\n\nconst arg = Eq(7);\nconst condition = Condition.from(arg);\nexpect(arg).toBe(condition);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"case-function\"\n    }}>{`Case: Function`}</h2>\n    <p>{`The function will be wrapped in `}<inlineCode parentName=\"p\">{`Test`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const arg = (x) => x > 10;\nconst condition = Condition.from(arg);\n\nexpect(condition.exec(20)).toEqual([20]);\nexpect(condition.exec(5)).toBe(null);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"case-regexp\"\n    }}>{`Case: RegExp`}</h2>\n    <p>{`The regex will be wrapped in `}<inlineCode parentName=\"p\">{`RegexTest`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const arg = /^ba.$/;\nconst condition = Condition.from(arg);\n\nexpect(condition.exec('bar')).toEqual(['bar']);\nexpect(condition.exec('baz')).toEqual(['baz']);\nexpect(condition.exec('foo')).toBe(null);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"case-other-object\"\n    }}>{`Case: Other Object`}</h2>\n    <p>{`The object will be used as a `}<inlineCode parentName=\"p\">{`MatchObject`}</inlineCode>{`. This can be nested as `}<inlineCode parentName=\"p\">{`MatchObject`}</inlineCode>{` uses\n`}<inlineCode parentName=\"p\">{`intoCondition`}</inlineCode>{` on the properties.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const arg = { a: 'foo', b: { c: Eq('bar').or(Eq('baz')) } };\nconst condition = Condition.from(arg);\n\nconst good = {\n  a: 'foo',\n  b: {\n    c: 'baz',\n  },\n};\n\nconst bad = {\n  a: 'foo',\n  b: {\n    c: 'quux',\n  },\n};\n\nexpect(condition.exec(good)).toEqual([good]);\nexpect(condition.exec(bad)).toBe(null);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"case-primitive\"\n    }}>{`Case: Primitive`}</h2>\n    <p>{`The final case is where it's a primitive, and we simply wrap it in `}<inlineCode parentName=\"p\">{`Eq`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`for (const value of [7, 'foo', null, undefined, true, false]) {\n  const condition = Condition.from(value);\n  expect(condition.exec(value)).toEqual([value]);\n}\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}